import mongoose from "mongoose";
import Question from "../models/Questions.js";
import UserAssessment from "../models/UserAssessment.js";
import User from "../models/User.js";
import QuestionLearning from "../models/QuestionLearning.js";
import { asyncHandler } from "../middlewares/asyncHandler.js";
import { AppError } from "../utils/errorHandler.js";
import { getCategoriesForSubscription, validateCategoriesForSubscription } from "../utils/subscription.js";
import PDFDocument from "pdfkit";

const VALID_SCORE_MIN = 1;
const VALID_SCORE_MAX = 7;

export const submitAssessment = asyncHandler(async (req, res) => {
  const userId = req.user?._id;

  if (!userId) {
    throw new AppError("User not authenticated", 401);
  }

  const { responses } = req.body || {};

  if (!Array.isArray(responses) || responses.length === 0) {
    throw new AppError("Responses are required", 400);
  }

  // Get user's subscription to validate categories
  const user = await User.findById(userId).select("currentSubscriptionType");
  
  if (!user) {
    throw new AppError("User not found", 404);
  }

  const subscriptionType = user.currentSubscriptionType || "Free";
  const availableCategories = getCategoriesForSubscription(subscriptionType);

  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const questionIds = responses
      .map((response) => response?.questionId)
      .filter((id) => mongoose.Types.ObjectId.isValid(id));

    if (!questionIds.length) {
      throw new AppError("No valid question IDs provided", 400);
    }

    const questions = await Question.find({ _id: { $in: questionIds } })
      .select(["_id", "category", "needKey", "needLabel", "sectionType", "parentQuestionId"])
      .lean();

    if (!questions.length) {
      throw new AppError("No matching questions found for given IDs", 400);
    }

    // Get all unique categories from questions
    const questionCategories = [...new Set(questions.map((q) => q.category))];

    // Validate categories against subscription
    const validation = validateCategoriesForSubscription(questionCategories, subscriptionType);
    if (!validation.isValid) {
      throw new AppError(validation.message, 403);
    }

    const categoryTotals = {};
    const categoryCounts = {};
    const needTotals = {};
    const needCounts = {};
    const validResponses = [];

    for (const response of responses) {
      const question = questions.find((q) => q._id.toString() === response.questionId);
      if (!question) {
        continue;
      }

      // Double-check: ensure question category is available for subscription (extra security)
      if (!availableCategories.includes(question.category)) {
        throw new AppError(
          `Question from category "${question.category}" is not available in your ${subscriptionType} subscription.`,
          403
        );
      }

      const score = Number(response.selectedOption);
      if (Number.isNaN(score) || score < VALID_SCORE_MIN || score > VALID_SCORE_MAX) {
        continue;
      }

      validResponses.push({
        questionId: question._id,
        selectedOption: score,
        category: question.category,
        needKey: question.needKey || null,
        needLabel: question.needLabel || null,
        sectionType: question.sectionType || "regular",
        parentQuestionId: question.parentQuestionId || null,
      });

      categoryTotals[question.category] = (categoryTotals[question.category] || 0) + score;
      categoryCounts[question.category] = (categoryCounts[question.category] || 0) + 1;

      if (question.needKey) {
        needTotals[question.needKey] = (needTotals[question.needKey] || 0) + score;
        needCounts[question.needKey] = (needCounts[question.needKey] || 0) + 1;
      }
    }

    if (!validResponses.length) {
      throw new AppError("No valid responses", 400);
    }

    const categoryScores = {};
    Object.keys(categoryTotals).forEach((categoryKey) => {
      categoryScores[categoryKey] = Number(
        (categoryTotals[categoryKey] / categoryCounts[categoryKey]).toFixed(2)
      );
    });

    const needScores = {};
    Object.keys(needTotals).forEach((nk) => {
      const q = questions.find((qq) => qq.needKey === nk);
      needScores[nk] = {
        score: Number((needTotals[nk] / needCounts[nk]).toFixed(2)),
        needLabel: q?.needLabel || null,
        category: q?.category || null,
      };
    });

    const overallScore =
      Object.keys(categoryScores).length > 0
        ? Number(
            (
              Object.values(categoryScores).reduce((sum, value) => sum + value, 0) /
              Object.values(categoryScores).length
            ).toFixed(2)
          )
        : 0;

    await UserAssessment.create(
      [
        {
          userId,
          responses: validResponses,
          categoryScores,
          needScores,
          overallScore,
          completedAt: new Date(),
        },
      ],
      { session }
    );

    // Update user flag to indicate assessment completion
    const completionDate = new Date();
    await User.findByIdAndUpdate(
      userId,
      {
        hasCompletedAssessment: true,
        assessmentCompletedAt: completionDate,
      },
      { session }
    );

    await session.commitTransaction();

    res.status(200).json({
      success: true,
      message: "Assessment submitted successfully",
      categoryScores,
      needScores,
      overallScore,
      hasCompletedAssessment: true,
    });
  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
});

export const getLatestAssessment = asyncHandler(async (req, res) => {
    const userId = req.user?._id;
  
    if (!userId) {
      throw new AppError("User not authenticated", 401);
    }
  
    const latestAssessment = await UserAssessment.findOne({ userId })
      .sort({ createdAt: -1 })
      .lean();
  
    if (!latestAssessment) {
      throw new AppError("No assessment found for this user", 404);
    }
  
    const categoryScores = latestAssessment.categoryScores || {};
    const needScores = latestAssessment.needScores || {};
  
    const overallScore =
      latestAssessment.overallScore ??
      (Object.keys(categoryScores).length
        ? Number(
            (
              Object.values(categoryScores).reduce((sum, value) => sum + value, 0) /
              Object.values(categoryScores).length
            ).toFixed(2)
          )
        : 0);
  
    // Define static chart metadata (bands and descriptions)
    const chartMeta = {
      performanceBands: [
        { label: "Dysfunctional / Extreme", range: [1, 2], color: "#E63946" },
        { label: "Getting By", range: [3, 4], color: "#F1C40F" },
        { label: "Thriving", range: [5, 6], color: "#2ECC71" },
        { label: "Maximizing", range: [7, 7], color: "#27AE60" },
      ],
      categoryDescriptions: {
        Survival: "Physical needs, health, energy, rest, and nutrition.",
        Safety: "Stability, financial security, and sense of control.",
        Social: "Belonging, love, connection, and relationships.",
        Self: "Confidence, respect, and personal achievement.",
        "Meta-Needs": "Purpose, creativity, contribution, and self-actualization.",
      },
    };
  
    // Optional insight logic (can expand later)
    const lowestCategories = Object.entries(categoryScores)
      .sort(([, a], [, b]) => a - b)
      .slice(0, 2)
      .map(([cat]) => cat);
  
    res.status(200).json({
      success: true,
      message: "Latest assessment retrieved successfully",
      data: {
        assessmentId: latestAssessment._id,
        categoryScores,
        needScores,
        overallScore,
        lowestCategories,
        completedAt: latestAssessment.createdAt || latestAssessment.completedAt,
        chartMeta,
      },
    });
  });

// Need-level report with lowest needs and linked learning content
export const getNeedReport = asyncHandler(async (req, res) => {
  const userId = req.user?._id;
  if (!userId) throw new AppError("User not authenticated", 401);

  const latestAssessment = await UserAssessment.findOne({ userId }).sort({ createdAt: -1 }).lean();
  if (!latestAssessment) throw new AppError("No assessment found for this user", 404);

  const needScores = latestAssessment.needScores || {};
  const categoryScores = latestAssessment.categoryScores || {};

  const sortedNeeds = Object.entries(needScores)
    .map(([needKey, val]) => ({ needKey, ...val }))
    .sort((a, b) => (a.score ?? 0) - (b.score ?? 0));

  const lowestNeeds = sortedNeeds.slice(0, 3);

  const learningByNeed = {};
  for (const n of lowestNeeds) {
    const learning = await QuestionLearning.findOne({ isActive: true })
      .populate({
        path: "questionId",
        match: { needKey: n.needKey },
        select: ["needKey", "needLabel", "category", "questionText"],
      })
      .lean();
    if (learning?.questionId) {
      learningByNeed[n.needKey] = {
        title: learning.title,
        learningType: learning.learningType,
        thumbnailUrl: learning.thumbnailUrl,
        questionId: learning.questionId._id,
        needLabel: learning.questionId.needLabel,
        category: learning.questionId.category,
      };
    } else {
      learningByNeed[n.needKey] = null;
    }
  }

  res.status(200).json({
    success: true,
    message: "Need-level report",
    data: {
      assessmentId: latestAssessment._id,
      needScores,
      categoryScores,
      lowestNeeds,
      learningByNeed,
      completedAt: latestAssessment.createdAt || latestAssessment.completedAt,
    },
  });
});

// Recommendations for next actions (learn, goal, coach) based on lowest need
export const getRecommendations = asyncHandler(async (req, res) => {
  const userId = req.user?._id;
  if (!userId) throw new AppError("User not authenticated", 401);

  const latestAssessment = await UserAssessment.findOne({ userId }).sort({ createdAt: -1 }).lean();
  if (!latestAssessment) throw new AppError("No assessment found for this user", 404);

  const needScores = latestAssessment.needScores || {};
  const sortedNeeds = Object.entries(needScores)
    .map(([needKey, val]) => ({ needKey, ...val }))
    .sort((a, b) => (a.score ?? 0) - (b.score ?? 0));

  const topNeed = sortedNeeds[0];

  const recommendations = [];

  if (topNeed) {
    const label = topNeed.needLabel || topNeed.needKey;
    recommendations.push({
      type: "learn",
      needKey: topNeed.needKey,
      needLabel: label,
      message: `Explore Learn & Grow content for ${label}`,
    });
    recommendations.push({
      type: "goal",
      needKey: topNeed.needKey,
      needLabel: label,
      message: `Set a goal to improve ${label}`,
    });
    recommendations.push({
      type: "coach",
      needKey: topNeed.needKey,
      needLabel: label,
      message: `Ask your coach about ${label}`,
    });
  }

  res.status(200).json({
    success: true,
    message: "Recommendations generated",
    data: {
      recommendations,
      primaryNeed: topNeed || null,
      assessmentId: latestAssessment._id,
    },
  });
});

  export const downloadAssessmentPDF = asyncHandler(async (req, res) => {
    const userId = req.user?._id;
    if (!userId) throw new AppError("User not authenticated", 401);
  
    const latestAssessment = await UserAssessment.findOne({ userId })
      .sort({ createdAt: -1 })
      .lean();
    if (!latestAssessment) throw new AppError("No assessment found", 404);
  
    const categoryScores = latestAssessment.categoryScores || {};
    const overallScore =
      latestAssessment.overallScore ??
      (Object.values(categoryScores).length
        ? Number(
            (
              Object.values(categoryScores).reduce((a, b) => a + b, 0) /
              Object.values(categoryScores).length
            ).toFixed(2)
          )
        : 0);
  
    // ---- Create PDF ----
    const doc = new PDFDocument({ margin: 50 });
    res.setHeader("Content-Type", "application/pdf");
    res.setHeader(
      "Content-Disposition",
      `attachment; filename="assessment-summary.pdf"`
    );
    doc.pipe(res);
  
    doc.fontSize(20).text("Self-Actualization Assessment Summary", { align: "center" });
    doc.moveDown();
  
    doc.fontSize(12).text(`Date: ${new Date(latestAssessment.createdAt).toLocaleDateString()}`);
    doc.text(`User ID: ${userId}`);
    doc.moveDown();
  
    doc.fontSize(14).text("Category Scores", { underline: true });
    doc.moveDown(0.5);
  
    Object.entries(categoryScores).forEach(([cat, val]) => {
      doc.text(`${cat}: ${val}/7`);
    });
  
    doc.moveDown(1);
    doc.fontSize(14).text(`Overall Score: ${overallScore}/7`, { bold: true });
    doc.moveDown(1);
  
    // Optional: add chart legend / band descriptions
    const bands = [
      { label: "Dysfunctional / Extreme", range: [1, 2] },
      { label: "Getting By", range: [3, 4] },
      { label: "Thriving", range: [5, 6] },
      { label: "Maximizing", range: [7, 7] },
    ];
    doc.fontSize(12).text("Performance Bands:", { underline: true });
    bands.forEach((b) => doc.text(`${b.label}  (${b.range[0]}-${b.range[1]})`));
  
    doc.end();
  });